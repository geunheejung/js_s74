# 코드스피츠74 - ES6+ 함수와 OOP 
실습

--- 3강 까지 필기 본 ---
루틴이란(ROUTINE)
- 반복적으로 사용되는 것 ex) 함수

서브루틴이란
- 로직을 모아놓고 여러번 호출 가능하게 하는 것

덧셈 연산이 일어날 경우 덧셈이라는 + 를 루틴이라 생각할 수 있다.
그리고 이 루틴은 좌항의 값과 우항의 값을 아규먼트로 보내는것이다. 좌항의 값을 우항에 더할 때 좌항의 값을 어딘가에 저장해두지 않고 우항에 값에 더할 수 있냐 했을 때는 불가능하다.
좌항의 값을 어딘가에 저장해두어야 그 값이 우항에 더할 수 있기 때문이다. 이처럼 덧셈 연산을 할 경우 연산 스택이 생기면서 메모리가 할당된다.

함수의 호출은 인자의 갯수에 따라서 인자를 위한 추가적인 메모리가 필요

이러한 메모리를 stack 이라 부른다.

서브루틴인지를 판단하는 기준은
누가 호출을 했고, 누가 호출을 당했냐이다.

서브루틴이 중첩되어있을 때 
A 서브루틴이 B 서브루틴을 불렀다 하면 A서브루틴은 누군가에겐 서브루틴일지라도 B서브루틴에게는 메인 루틴이 되는것이다.

함수 A -> 함수 B -> 함수 C 가 있을 때 A -> B 로 넘어갈 때 A의 호출 객체를 Keep해놓는데 이 때 함수의 크기에 따라 메모리가 할당된다. 그러므로 함수가 겁나 클 경우 메모리도 겁나 크게 할당되기 때문에 프로그램이 죽을 수 있다. 그래서 Javascript에는 몇회이상의 함수가 중첩적으로 호출될 경우에 대한 제약이 있다.
여기서 메인루틴에서 서브루틴으로 넘어가면서 메인루틴의 컨텍스트를 Keep 해놓는 이유는 서브루틴이 종료되면서 다시 메인루틴으로 넘어올 때 그 넘어간 시점에서 메인 루틴이 진행되어야되기 때문에 메인루틴에서 서브루틴으로 넘어가면서 메인루틴의 컨텍스트를 지워버리면 안된다. 
이러한 함수의 중첩 연산과정에서 스택과 같이 쌓이는데 이를 call stack이라한다.

실제 스택은 나중에 들어간것이 먼저 나오는데

함수도 가장 마지막 서브루틴이 종료되면서 가장 먼저 메모리가 풀린다.

함수와 함수가 또는 함수와 서브루틴이 대화하는 방법은 전해주는 아규먼트를 값으로 보내주어서 복사본을 전해주는것이다. 그러면 매번 호출할 때 마다 복사본을 넘겨주기때문에 어떻게 호출하든 중첩해서 호출하든 항상 복사본을 다루기에 문제가 없다.

그러나 값이 아닌 참조를 보낼 경우 문제가 있다.
하나의 참조값을 여러 함수에 인자로 보낼 경우 여러 함수는 하나의 참조를 바라보고있고, 여러 함수 중 어떤 함수가 이 참조값을 바꿀 경우 모든 함수는 같은 참조값을 바라보기에 영향을 받는다. 

이래서 React에서 Props를 넘겨줄때 자식 컴포넌트에서 내려받은 Props를 변경하는것을 막았나보다. 

Javascript에서는 언어가 하는것이 아닌 우리의 규칙적으로 참조값을 인자로 받을 경우 readonly 시킨다.
react에서는 언어적으로 readonly시킨다.

설령 인자로 넘겨준 참조에 setter가 있을지라도 readOnly로 사용하는것이 좋다.

함수에서 참조를 return할 경우에도 문제가 생긴다.
참조는 다른 참조를 물수있다. 그래서 return 하면서 우리가 원하는 참조이외에도 readOnly라 생각한 아규먼트도 물어서 return할 수 있고, 리턴된 함수 내부에 있는 다른 참조값을 물어서 내려올 수 있기 때문이다. 그래서 참조를 리턴할 때는 기존의 내부 함수의 참조값을 그대로 보내는것이 아닌 새로운 참조값을 반환함으로써 기존 함수의 참조를 끊는다.

디버깅 타임을 줄이는것이 핵심

-- 결합도, 응집도
소프트웨어 공학의 전통적인 이론에 따르면 유지보수성이 높은 소프트웨어는 프로그램의 각 요소들이 결합도는 낮게, 응집도는 높게

결합도란(coupling)?
- 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지 나타내는 정도. -> 결합도가 낮다는 것은 그것이 다른 요소들과 관계를 그다지 맺지 않은 상태(의존이 적다)

응집도란(cohesion)?
- 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도 
